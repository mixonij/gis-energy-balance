//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IGeoDataService {
    getCities(): Promise<City[] | null>;
    getAreas(cityId: number): Promise<CityDistrict[] | null>;
    getPipes(): Promise<HeatingPipe[] | null>;
    getPipeGroups(): Promise<Pipe[] | null>;
    getHeatingStations(): Promise<HeatingStation[] | null>;
}

export class GeoDataService implements IGeoDataService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getCities(  cancelToken?: CancelToken | undefined): Promise<City[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCities(_response);
        });
    }

    protected processGetCities(response: AxiosResponse): Promise<City[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(City.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<City[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City[] | null>(null as any);
    }

    getAreas(cityId: number , cancelToken?: CancelToken | undefined): Promise<CityDistrict[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetAreas/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAreas(_response);
        });
    }

    protected processGetAreas(response: AxiosResponse): Promise<CityDistrict[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityDistrict.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CityDistrict[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityDistrict[] | null>(null as any);
    }

    getPipes(  cancelToken?: CancelToken | undefined): Promise<HeatingPipe[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetPipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPipes(_response);
        });
    }

    protected processGetPipes(response: AxiosResponse): Promise<HeatingPipe[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HeatingPipe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<HeatingPipe[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HeatingPipe[] | null>(null as any);
    }

    getPipeGroups(  cancelToken?: CancelToken | undefined): Promise<Pipe[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetPipeGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPipeGroups(_response);
        });
    }

    protected processGetPipeGroups(response: AxiosResponse): Promise<Pipe[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pipe.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Pipe[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pipe[] | null>(null as any);
    }

    getHeatingStations(  cancelToken?: CancelToken | undefined): Promise<HeatingStation[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetHeatingStations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHeatingStations(_response);
        });
    }

    protected processGetHeatingStations(response: AxiosResponse): Promise<HeatingStation[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HeatingStation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<HeatingStation[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HeatingStation[] | null>(null as any);
    }
}

export class City implements ICity {
    id!: number;
    name!: string;
    nativeName!: string;
    northWestPoint!: Point;
    southEastPoint!: Point;
    minZoom!: number;
    cityDistricts!: CityDistrict[];

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.northWestPoint = new Point();
            this.southEastPoint = new Point();
            this.cityDistricts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.northWestPoint = _data["northWestPoint"] ? Point.fromJS(_data["northWestPoint"]) : new Point();
            this.southEastPoint = _data["southEastPoint"] ? Point.fromJS(_data["southEastPoint"]) : new Point();
            this.minZoom = _data["minZoom"];
            if (Array.isArray(_data["cityDistricts"])) {
                this.cityDistricts = [] as any;
                for (let item of _data["cityDistricts"])
                    this.cityDistricts!.push(CityDistrict.fromJS(item));
            }
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["northWestPoint"] = this.northWestPoint ? this.northWestPoint.toJSON() : <any>undefined;
        data["southEastPoint"] = this.southEastPoint ? this.southEastPoint.toJSON() : <any>undefined;
        data["minZoom"] = this.minZoom;
        if (Array.isArray(this.cityDistricts)) {
            data["cityDistricts"] = [];
            for (let item of this.cityDistricts)
                data["cityDistricts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICity {
    id: number;
    name: string;
    nativeName: string;
    northWestPoint: Point;
    southEastPoint: Point;
    minZoom: number;
    cityDistricts: CityDistrict[];
}

export class Point implements IPoint {
    x!: number;
    y!: number;

    constructor(data?: IPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

export interface IPoint {
    x: number;
    y: number;
}

export class CityDistrict implements ICityDistrict {
    id!: number;
    cityId!: number;
    geometryPoints!: Point[];
    buildings!: Building[];

    constructor(data?: ICityDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.geometryPoints = [];
            this.buildings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            if (Array.isArray(_data["geometryPoints"])) {
                this.geometryPoints = [] as any;
                for (let item of _data["geometryPoints"])
                    this.geometryPoints!.push(Point.fromJS(item));
            }
            if (Array.isArray(_data["buildings"])) {
                this.buildings = [] as any;
                for (let item of _data["buildings"])
                    this.buildings!.push(Building.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CityDistrict {
        data = typeof data === 'object' ? data : {};
        let result = new CityDistrict();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        if (Array.isArray(this.geometryPoints)) {
            data["geometryPoints"] = [];
            for (let item of this.geometryPoints)
                data["geometryPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICityDistrict {
    id: number;
    cityId: number;
    geometryPoints: Point[];
    buildings: Building[];
}

export class Building implements IBuilding {
    livingSquare!: number;
    residentsCount!: number;
    aOk!: number;
    af!: number;
    v!: number;
    id!: number;
    geometryPoints!: Point[];

    constructor(data?: IBuilding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.geometryPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.livingSquare = _data["livingSquare"];
            this.residentsCount = _data["residentsCount"];
            this.aOk = _data["aOk"];
            this.af = _data["af"];
            this.v = _data["v"];
            this.id = _data["id"];
            if (Array.isArray(_data["geometryPoints"])) {
                this.geometryPoints = [] as any;
                for (let item of _data["geometryPoints"])
                    this.geometryPoints!.push(Point.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Building {
        data = typeof data === 'object' ? data : {};
        let result = new Building();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["livingSquare"] = this.livingSquare;
        data["residentsCount"] = this.residentsCount;
        data["aOk"] = this.aOk;
        data["af"] = this.af;
        data["v"] = this.v;
        data["id"] = this.id;
        if (Array.isArray(this.geometryPoints)) {
            data["geometryPoints"] = [];
            for (let item of this.geometryPoints)
                data["geometryPoints"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBuilding {
    livingSquare: number;
    residentsCount: number;
    aOk: number;
    af: number;
    v: number;
    id: number;
    geometryPoints: Point[];
}

export class HeatingPipe implements IHeatingPipe {
    id!: number;
    points!: Point[];
    dPod!: number;
    dObr!: number;

    constructor(data?: IHeatingPipe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.points = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(Point.fromJS(item));
            }
            this.dPod = _data["dPod"];
            this.dObr = _data["dObr"];
        }
    }

    static fromJS(data: any): HeatingPipe {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingPipe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        data["dPod"] = this.dPod;
        data["dObr"] = this.dObr;
        return data;
    }
}

export interface IHeatingPipe {
    id: number;
    points: Point[];
    dPod: number;
    dObr: number;
}

export class Pipe implements IPipe {
    id!: number;
    points!: GeographyPoint[];
    dOut?: number | undefined;
    dIn?: number | undefined;
    length?: number | undefined;

    constructor(data?: IPipe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.points = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(GeographyPoint.fromJS(item));
            }
            this.dOut = _data["dOut"];
            this.dIn = _data["dIn"];
            this.length = _data["length"];
        }
    }

    static fromJS(data: any): Pipe {
        data = typeof data === 'object' ? data : {};
        let result = new Pipe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        data["dOut"] = this.dOut;
        data["dIn"] = this.dIn;
        data["length"] = this.length;
        return data;
    }
}

export interface IPipe {
    id: number;
    points: GeographyPoint[];
    dOut?: number | undefined;
    dIn?: number | undefined;
    length?: number | undefined;
}

export class GeographyPoint implements IGeographyPoint {
    x!: number;
    y!: number;

    constructor(data?: IGeographyPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): GeographyPoint {
        data = typeof data === 'object' ? data : {};
        let result = new GeographyPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

export interface IGeographyPoint {
    x: number;
    y: number;
}

export class HeatingStation implements IHeatingStation {
    id!: number;
    cityId!: number;
    nominalPower!: number;
    points!: Point[];

    constructor(data?: IHeatingStation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.points = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            this.nominalPower = _data["nominalPower"];
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(Point.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HeatingStation {
        data = typeof data === 'object' ? data : {};
        let result = new HeatingStation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        data["nominalPower"] = this.nominalPower;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHeatingStation {
    id: number;
    cityId: number;
    nominalPower: number;
    points: Point[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}