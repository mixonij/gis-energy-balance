//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IGeoDataService {
    getHouses(cityId: number): Promise<Building[] | null>;
    getCities(): Promise<City[] | null>;
    getAreas(cityId: number): Promise<Area[] | null>;
}

export class GeoDataService implements IGeoDataService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    getHouses(cityId: number , cancelToken?: CancelToken | undefined): Promise<Building[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetHouses/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetHouses(_response);
        });
    }

    protected processGetHouses(response: AxiosResponse): Promise<Building[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Building.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Building[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Building[] | null>(null as any);
    }

    getCities(  cancelToken?: CancelToken | undefined): Promise<City[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCities(_response);
        });
    }

    protected processGetCities(response: AxiosResponse): Promise<City[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(City.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<City[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City[] | null>(null as any);
    }

    getAreas(cityId: number , cancelToken?: CancelToken | undefined): Promise<Area[] | null> {
        let url_ = this.baseUrl + "/api/geodata/GetAreas/{cityId}";
        if (cityId === undefined || cityId === null)
            throw new Error("The parameter 'cityId' must be defined.");
        url_ = url_.replace("{cityId}", encodeURIComponent("" + cityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAreas(_response);
        });
    }

    protected processGetAreas(response: AxiosResponse): Promise<Area[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Area.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Area[] | null>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Area[] | null>(null as any);
    }
}

export class Building implements IBuilding {
    id!: number;
    cityId!: number;
    coordinates!: NpgsqlPoint;
    polygonCoordinates!: NpgsqlPoint[];
    buildingsInfos!: BuildingsInfo[];
    city!: City;

    constructor(data?: IBuilding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.coordinates = new NpgsqlPoint();
            this.polygonCoordinates = [];
            this.buildingsInfos = [];
            this.city = new City();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            this.coordinates = _data["coordinates"] ? NpgsqlPoint.fromJS(_data["coordinates"]) : new NpgsqlPoint();
            if (Array.isArray(_data["polygonCoordinates"])) {
                this.polygonCoordinates = [] as any;
                for (let item of _data["polygonCoordinates"])
                    this.polygonCoordinates!.push(NpgsqlPoint.fromJS(item));
            }
            if (Array.isArray(_data["buildingsInfos"])) {
                this.buildingsInfos = [] as any;
                for (let item of _data["buildingsInfos"])
                    this.buildingsInfos!.push(BuildingsInfo.fromJS(item));
            }
            this.city = _data["city"] ? City.fromJS(_data["city"]) : new City();
        }
    }

    static fromJS(data: any): Building {
        data = typeof data === 'object' ? data : {};
        let result = new Building();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        data["coordinates"] = this.coordinates ? this.coordinates.toJSON() : <any>undefined;
        if (Array.isArray(this.polygonCoordinates)) {
            data["polygonCoordinates"] = [];
            for (let item of this.polygonCoordinates)
                data["polygonCoordinates"].push(item.toJSON());
        }
        if (Array.isArray(this.buildingsInfos)) {
            data["buildingsInfos"] = [];
            for (let item of this.buildingsInfos)
                data["buildingsInfos"].push(item.toJSON());
        }
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBuilding {
    id: number;
    cityId: number;
    coordinates: NpgsqlPoint;
    polygonCoordinates: NpgsqlPoint[];
    buildingsInfos: BuildingsInfo[];
    city: City;
}

export class NpgsqlPoint implements INpgsqlPoint {
    x!: number;
    y!: number;

    constructor(data?: INpgsqlPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): NpgsqlPoint {
        data = typeof data === 'object' ? data : {};
        let result = new NpgsqlPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

export interface INpgsqlPoint {
    x: number;
    y: number;
}

export class BuildingsInfo implements IBuildingsInfo {
    id!: number;
    buildingId!: number;
    builtYear?: number | undefined;
    building!: Building;

    constructor(data?: IBuildingsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.building = new Building();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.buildingId = _data["buildingId"];
            this.builtYear = _data["builtYear"];
            this.building = _data["building"] ? Building.fromJS(_data["building"]) : new Building();
        }
    }

    static fromJS(data: any): BuildingsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["buildingId"] = this.buildingId;
        data["builtYear"] = this.builtYear;
        data["building"] = this.building ? this.building.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBuildingsInfo {
    id: number;
    buildingId: number;
    builtYear?: number | undefined;
    building: Building;
}

export class City implements ICity {
    id!: number;
    nameRussian!: string;
    northWestBound!: NpgsqlPoint;
    southEastBound!: NpgsqlPoint;
    minZoom!: number;
    buildings!: Building[];

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.northWestBound = new NpgsqlPoint();
            this.southEastBound = new NpgsqlPoint();
            this.buildings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameRussian = _data["nameRussian"];
            this.northWestBound = _data["northWestBound"] ? NpgsqlPoint.fromJS(_data["northWestBound"]) : new NpgsqlPoint();
            this.southEastBound = _data["southEastBound"] ? NpgsqlPoint.fromJS(_data["southEastBound"]) : new NpgsqlPoint();
            this.minZoom = _data["minZoom"];
            if (Array.isArray(_data["buildings"])) {
                this.buildings = [] as any;
                for (let item of _data["buildings"])
                    this.buildings!.push(Building.fromJS(item));
            }
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameRussian"] = this.nameRussian;
        data["northWestBound"] = this.northWestBound ? this.northWestBound.toJSON() : <any>undefined;
        data["southEastBound"] = this.southEastBound ? this.southEastBound.toJSON() : <any>undefined;
        data["minZoom"] = this.minZoom;
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICity {
    id: number;
    nameRussian: string;
    northWestBound: NpgsqlPoint;
    southEastBound: NpgsqlPoint;
    minZoom: number;
    buildings: Building[];
}

export class Area implements IArea {
    id!: number;
    cityId!: number;
    polygonCoordinates!: NpgsqlPoint[];

    constructor(data?: IArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.polygonCoordinates = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cityId = _data["cityId"];
            if (Array.isArray(_data["polygonCoordinates"])) {
                this.polygonCoordinates = [] as any;
                for (let item of _data["polygonCoordinates"])
                    this.polygonCoordinates!.push(NpgsqlPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Area {
        data = typeof data === 'object' ? data : {};
        let result = new Area();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cityId"] = this.cityId;
        if (Array.isArray(this.polygonCoordinates)) {
            data["polygonCoordinates"] = [];
            for (let item of this.polygonCoordinates)
                data["polygonCoordinates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArea {
    id: number;
    cityId: number;
    polygonCoordinates: NpgsqlPoint[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}